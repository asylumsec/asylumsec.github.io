[[swift-iscsi]]
= Triple-O Swift ISCSI
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:


toc::[]

== Overview
For my enviroment I wanted to be able to use a single multi-purpose storage server, but I didn't want to lose functionality.

The setup for this is to support 3 controller nodes, so I created three targets on my SAN. The target ends with the hostname of the controller node, IE overcloud-controller-0 etc


[[modifications-preconfig]]
=== Adding support to mount iscsi drives
The purpose of this is to show how you can easily customize your Openstack deployment to suit your enviroment. The following will mount an iscsi drive on each controller node in the pre-config phase of deployment

First you need to add in support for pre-config of the controller node.

This file is called controller-pre-deploy.yaml
====
----
resource_registry:
  OS::TripleO::ControllerExtraConfigPre: extraconfig/pre_deploy/controller/controller-extra-config-pre-deploy.yaml <1>
parameter_defaults:
  SwiftRawDisks: {"sdb": {}} <2>
  SwiftReplicas: 1 <3>
----
<1> Please note the directory, and ensure the file that is being loaded actually exists.
<2> Change this value to meet what disk your lun gets mounted as. If you only have one disk, its more than likely sdb
<3> The SAN is taking care of replicating the data, no sense in replicating it 3 more times.
====

Next we add the directory and create the file to be loaded.

====
----
mkdir -p extraconfig/pre_deploy/controller/
touch extraconfig/pre_deploy/controller/controller-extra-config-pre-deploy.yaml
----
====

You can open this file up in your favorite editor and insert the following.
====
----
heat_template_version: 2014-10-16

description: >
  Mount iSCSI Drives to Controller Nodes, Create domains file for keystone

# Note extra parameters can be defined, then passed data via the
# environment parameter_defaults, without modifying the parent template
parameters:
  server:
    type: string

resources:
  AttachIscsiDrive:
    type: OS::Heat::SoftwareConfig
    properties:
      group: script
      config: |
        #!/bin/sh
        export _HOSTNAME=$(hostname -s) <1>
        /sbin/iscsiadm -m discovery -t sendtargets -p 192.168.254.235 <2>
        /sbin/iscsiadm -m node -T iqn.2010-01.org.example.hostname:$_HOSTNAME --login <3>

  AttachIscsiDriveDeployment:
    type: OS::Heat::SoftwareDeployment
    properties:
      name: AttachIscsiDriveDeployment
      config: {get_resource: AttachIscsiDrive}
      actions: ['CREATE'] # Only do this on CREATE
      server: {get_param: server}

  WipeIscsiDisks:
    type: OS::Heat::SoftwareConfig
    properties:
      group: script
      config: |
        #!/bin/sh
        /usr/bin/dd if=/dev/zero of=/dev/sdb bs=128K count=100

  WipeIscsiDiskDeployment:
    type: OS::Heat::SoftwareDeployment
    properties:
      name: WipeIscsiDiskDeployment
      server: {get_param: server}
      config: {get_resource: WipeIscsiDisks}
      actions: ['DELETE'] # Only do this on DELETE

outputs:
  deploy_stderr:
   description: Captured stderr from the configuration execution
   value: {get_attr: [AttachIscsiDriveDeployment, deploy_stderr]}
  deploy_stdout:
    description: Captured stdout from the configuration execution
    value: {get_attr: [AttachIscsiDriveDeployment, deploy_stdout]}
----
<1> What this does is get a unique name from each controller, so they can mount different targets
<2> Don't forget to change the IP to meet your enviroment
<3> The target name is broken into two pieces. First the target server portal name iqn.2010-01.org.example.hostname and then our unique hostname variable created in 1
====

Enjoy
